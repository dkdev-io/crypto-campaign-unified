#!/bin/bash

# Flexible Version Management System
# Supports automatic semantic versioning and custom feature releases

set -e

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

echo -e "${MAGENTA}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${MAGENTA}    🔢 VERSION MANAGER - Smart Versioning${NC}"
echo -e "${MAGENTA}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo ""

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo -e "${RED}❌ Not in a git repository!${NC}"
    exit 1
fi

# Check for package.json
if [ ! -f "package.json" ]; then
    echo -e "${RED}❌ package.json not found!${NC}"
    exit 1
fi

# Get current version from package.json
CURRENT_VERSION=$(node -p "require('./package.json').version")
echo -e "${BLUE}📍 Current version: ${YELLOW}v$CURRENT_VERSION${NC}"

# Function to increment version
increment_version() {
    local version=$1
    local type=$2
    
    # Split version into major.minor.patch
    IFS='.' read -ra VERSION_PARTS <<< "$version"
    local major=${VERSION_PARTS[0]}
    local minor=${VERSION_PARTS[1]}
    local patch=${VERSION_PARTS[2]}
    
    case $type in
        patch)
            patch=$((patch + 1))
            ;;
        minor)
            minor=$((minor + 1))
            patch=0
            ;;
        major)
            major=$((major + 1))
            minor=0
            patch=0
            ;;
    esac
    
    echo "$major.$minor.$patch"
}

# Function to update package.json version
update_package_version() {
    local new_version=$1
    
    # Use node to update package.json
    node -e "
        const fs = require('fs');
        const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        pkg.version = '$new_version';
        fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
    "
}

# Function to get commit messages since last tag
get_recent_changes() {
    local last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
    
    if [ -z "$last_tag" ]; then
        # No previous tags, get all commits
        git log --oneline --pretty=format:"• %s" HEAD | head -20
    else
        # Get commits since last tag
        git log --oneline --pretty=format:"• %s" "$last_tag"..HEAD
    fi
}

# Function to create feature-based tag
create_feature_tag() {
    local version=$1
    local feature_name=$2
    local tag_name="v$version-$feature_name"
    
    echo -e "${BLUE}🏷️  Creating feature tag: ${CYAN}$tag_name${NC}"
    
    # Get changes for this release
    local changes=$(get_recent_changes)
    
    # Create annotated tag with changelog
    git tag -a "$tag_name" -m "Release $tag_name

📋 Changes in this release:
$changes

🚀 Generated by Version Manager
📅 $(date '+%Y-%m-%d %H:%M:%S')"
    
    echo -e "${GREEN}✓ Created tag: $tag_name${NC}"
    return 0
}

# Function to create standard tag
create_standard_tag() {
    local version=$1
    local tag_name="v$version"
    
    echo -e "${BLUE}🏷️  Creating standard tag: ${CYAN}$tag_name${NC}"
    
    # Get changes for this release
    local changes=$(get_recent_changes)
    
    # Create annotated tag with changelog
    git tag -a "$tag_name" -m "Release $tag_name

📋 Changes in this release:
$changes

🚀 Generated by Version Manager
📅 $(date '+%Y-%m-%d %H:%M:%S')"
    
    echo -e "${GREEN}✓ Created tag: $tag_name${NC}"
    return 0
}

# Main version bumping logic
case "${1:-help}" in
    patch)
        echo -e "${BLUE}🔧 Bumping patch version...${NC}"
        NEW_VERSION=$(increment_version "$CURRENT_VERSION" "patch")
        ;;
    minor)
        echo -e "${BLUE}🔧 Bumping minor version...${NC}"
        NEW_VERSION=$(increment_version "$CURRENT_VERSION" "minor")
        ;;
    major)
        echo -e "${BLUE}🔧 Bumping major version...${NC}"
        NEW_VERSION=$(increment_version "$CURRENT_VERSION" "major")
        ;;
    custom)
        echo -e "${CYAN}✨ Custom Version Mode${NC}"
        echo ""
        echo "Options:"
        echo "  1) Set specific version (e.g., 2.1.0)"
        echo "  2) Create feature release (e.g., v2.0.0-crypto-ready)"
        echo ""
        read -p "Choose option (1-2): " option
        
        case $option in
            1)
                read -p "Enter new version (x.y.z): " NEW_VERSION
                if [[ ! $NEW_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                    echo -e "${RED}❌ Invalid version format. Use x.y.z${NC}"
                    exit 1
                fi
                ;;
            2)
                read -p "Enter base version (x.y.z): " NEW_VERSION
                if [[ ! $NEW_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                    echo -e "${RED}❌ Invalid version format. Use x.y.z${NC}"
                    exit 1
                fi
                read -p "Enter feature name (e.g., crypto-ready): " FEATURE_NAME
                if [ -z "$FEATURE_NAME" ]; then
                    echo -e "${RED}❌ Feature name cannot be empty${NC}"
                    exit 1
                fi
                CUSTOM_FEATURE=true
                ;;
            *)
                echo -e "${RED}❌ Invalid option${NC}"
                exit 1
                ;;
        esac
        ;;
    help|*)
        echo "Version Manager Usage:"
        echo ""
        echo "Automatic semantic versioning:"
        echo "  ./scripts/version.sh patch   - Bug fixes (1.0.0 → 1.0.1)"
        echo "  ./scripts/version.sh minor   - New features (1.0.0 → 1.1.0)"
        echo "  ./scripts/version.sh major   - Breaking changes (1.0.0 → 2.0.0)"
        echo ""
        echo "Custom versioning:"
        echo "  ./scripts/version.sh custom  - Interactive custom version/feature"
        echo ""
        echo "NPM shortcuts:"
        echo "  npm run version:patch"
        echo "  npm run version:minor"
        echo "  npm run version:major"
        echo "  npm run version:custom"
        echo ""
        echo "Examples of feature releases:"
        echo "  v2.0.0-crypto-ready"
        echo "  v1.5.0-mobile-support"
        echo "  v3.0.0-beta"
        exit 0
        ;;
esac

# Show the change
echo -e "${YELLOW}📈 Version change: v$CURRENT_VERSION → v$NEW_VERSION${NC}"

# Confirm the change
echo ""
read -p "Proceed with version bump? (y/n): " confirm
if [[ $confirm != "y" && $confirm != "Y" ]]; then
    echo "Cancelled"
    exit 0
fi

# Check for uncommitted changes
if ! git diff --quiet || ! git diff --staged --quiet; then
    echo -e "${YELLOW}⚠️  You have uncommitted changes.${NC}"
    echo "Options:"
    echo "  1) Commit changes and continue"
    echo "  2) Stash changes and continue"
    echo "  3) Cancel"
    
    read -p "Choose option (1-3): " choice
    case $choice in
        1)
            git add -A
            git commit -m "Pre-release commit for v$NEW_VERSION"
            ;;
        2)
            git stash push -m "Pre-release stash for v$NEW_VERSION"
            ;;
        *)
            echo "Cancelled"
            exit 0
            ;;
    esac
fi

# Update package.json
echo -e "${BLUE}📝 Updating package.json...${NC}"
update_package_version "$NEW_VERSION"

# Commit the version change
git add package.json
git commit -m "🔢 Bump version to v$NEW_VERSION

📦 Package version updated
🏷️  Ready for tagging

🚀 Generated by Version Manager"

# Create appropriate tag
if [ "$CUSTOM_FEATURE" = true ]; then
    create_feature_tag "$NEW_VERSION" "$FEATURE_NAME"
    FINAL_TAG="v$NEW_VERSION-$FEATURE_NAME"
else
    create_standard_tag "$NEW_VERSION"
    FINAL_TAG="v$NEW_VERSION"
fi

# Show summary
echo ""
echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${GREEN}✅ Version Successfully Updated!${NC}"
echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo ""
echo -e "${CYAN}📊 Summary:${NC}"
echo "  • Old version: v$CURRENT_VERSION"
echo "  • New version: v$NEW_VERSION"
echo "  • Git tag: $FINAL_TAG"
echo ""
echo -e "${YELLOW}Next steps:${NC}"
echo "  • Push changes: ${CYAN}git push && git push --tags${NC}"
echo "  • Create release: ${CYAN}./scripts/release.sh${NC}"
echo "  • Generate changelog: ${CYAN}./scripts/changelog.sh${NC}"